name: Turnip MTR Build

on:
  schedule:
    # Runs at 00:00 UTC every day (24 hours)
    - cron: '0 0 * * *'
  # Allows you to run it manually from the Actions tab for testing
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        variant: [A840P, A8XX]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y bison flex python3-pip pkg-config patchelf ninja-build zip rsync glslang-tools
          pip3 install meson mako jinja2 pyyaml ply --break-system-packages

      - name: Cache Android NDK
        id: cache-ndk
        uses: actions/cache@v4
        with:
          path: android-ndk-r27d
          key: ndk-r27d-linux

      - name: Install NDK
        if: steps.cache-ndk.outputs.cache-hit != 'true'
        run: |
          # Only runs if NDK is not found in cache
          # -nv flag prevents log spam (thousands of lines) while still showing errors
          wget -nv https://dl.google.com/android/repository/android-ndk-r27d-linux.zip
          unzip -q android-ndk-r27d-linux.zip

      - name: Setup NDK Path
        run: |
          echo "ANDROID_NDK_HOME=$GITHUB_WORKSPACE/android-ndk-r27d" >> $GITHUB_ENV

      - name: Clone Mesa
        run: |
          git clone --depth=200 https://gitlab.freedesktop.org/mesa/mesa.git
          cd mesa
          echo "MESA_COMMIT=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Create Meson Cross File
        run: |
          mkdir -p ~/.local/share/meson/cross/
          cat <<EOF > ~/.local/share/meson/cross/android-aarch64
          [binaries]
          ar = '$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar'
          c = ['ccache', '$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android35-clang']
          cpp = ['ccache', '$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android35-clang++']
          c_ld = 'lld'
          cpp_ld = 'lld'
          strip = '$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip'
          pkg-config = ['env', 'PKG_CONFIG_LIBDIR=DISABLED', 'pkg-config']

          [host_machine]
          system = 'android'
          cpu_family = 'aarch64'
          cpu = 'armv8'
          endian = 'little'
          EOF

      - name: Apply Common Patches
        run: |
          cd mesa
          # 1. Scaling / Clamp Fix (tu_pipeline.cc)
          sed -i 's/min.x = MAX2(min.x, 0);/min.x = CLAMP(min.x, 0, 16383);/' src/freedreno/vulkan/tu_pipeline.cc
          sed -i 's/min.y = MAX2(min.y, 0);/min.y = CLAMP(min.y, 0, 16383);/' src/freedreno/vulkan/tu_pipeline.cc
          sed -i 's/max.x = MAX2(max.x, 1);/max.x = CLAMP(max.x, 1, 16383);/' src/freedreno/vulkan/tu_pipeline.cc
          sed -i 's/max.y = MAX2(max.y, 1);/max.y = CLAMP(max.y, 1, 16383);/' src/freedreno/vulkan/tu_pipeline.cc
          sed -i 's/uint32_t min_x = scissor->offset.x;/uint32_t min_x = CLAMP(scissor->offset.x, 0, 16383);/' src/freedreno/vulkan/tu_pipeline.cc
          sed -i 's/uint32_t min_y = scissor->offset.y;/uint32_t min_y = CLAMP(scissor->offset.y, 0, 16383);/' src/freedreno/vulkan/tu_pipeline.cc
          sed -i 's/uint32_t max_x = min_x + scissor->extent.width - 1;/uint32_t max_x = CLAMP(min_x + scissor->extent.width - 1, 0, 16383);/' src/freedreno/vulkan/tu_pipeline.cc
          sed -i 's/uint32_t max_y = min_y + scissor->extent.height - 1;/uint32_t max_y = CLAMP(min_y + scissor->extent.height - 1, 0, 16383);/' src/freedreno/vulkan/tu_pipeline.cc

          # 2. DECK_EMU Flag (tu_util.h & tu_util.cc)
          sed -i '/TU_DEBUG_FORCE_CONCURRENT_BINNING = BITFIELD64_BIT(36),/a \   TU_DEBUG_DECK_EMU                 = BITFIELD64_BIT(37),' src/freedreno/vulkan/tu_util.h
          sed -i '/{ "dynamic", TU_DEBUG_DYNAMIC },/a \   { "deck_emu", TU_DEBUG_DECK_EMU },' src/freedreno/vulkan/tu_util.cc

          # 3. AMD Spoofing (tu_device.cc)
          sed -i '/props->deviceID = pdevice->dev_id.chip_id;/a \ \n   if (TU_DEBUG(DECK_EMU)) {\n      props->vendorID = 0x1002;\n      props->deviceID = 0x163F;\n   }' src/freedreno/vulkan/tu_device.cc
          sed -i 's/strcpy(props->deviceName, pdevice->name);/strcpy(props->deviceName, pdevice->name);\n   if (TU_DEBUG(DECK_EMU)) {\n      strcpy(props->deviceName, "AMD Custom GPU 0405 (RADV VANGOGH)");\n   }/' src/freedreno/vulkan/tu_device.cc

          # 4. vk_sync_timeline Fix - SMART PARSER (Prevents C compilation errors)
          cat <<'EOF' > vk_sync_fix.py
          import sys

          path = 'src/vulkan/runtime/vk_sync_timeline.c'
          try:
              with open(path, 'r') as f: content = f.read()
          except FileNotFoundError:
              print(f"File not found: {path}"); sys.exit(1)

          start_marker = 'vk_sync_timeline_wait_locked'
          new_code = r'''vk_sync_timeline_wait_locked(struct vk_device *device,
                                                 struct vk_sync_timeline_state *state,
                                                 uint64_t wait_value,
                                                 enum vk_sync_wait_flags wait_flags,
                                                 uint64_t abs_timeout_ns)
          {
              struct timespec abs_timeout_ts;
              timespec_from_nsec(&abs_timeout_ts, abs_timeout_ns);

              while (state->highest_past < wait_value) {
                  struct vk_sync_timeline_point *point = NULL;
                  list_for_each_entry(struct vk_sync_timeline_point, p,
                                      &state->pending_points, link) {
                      if (p->value >= wait_value) {
                          vk_sync_timeline_ref_point_locked(p);
                          point = p;
                          break;
                      }
                  }
                  if (!point) {
                      int ret = u_cnd_monotonic_timedwait(&state->cond, &state->mutex, &abs_timeout_ts);
                      if (ret == thrd_timedout) return VK_TIMEOUT;
                      if (ret != thrd_success) return vk_errorf(device, VK_ERROR_UNKNOWN, "cnd_timedwait failed");
                      continue;
                  }
                  mtx_unlock(&state->mutex);
                  VkResult r = vk_sync_wait(device, &point->sync, 0, VK_SYNC_WAIT_COMPLETE, abs_timeout_ns);
                  mtx_lock(&state->mutex);
                  vk_sync_timeline_unref_point_locked(device, state, point);
                  if (r != VK_SUCCESS) return r;
                  vk_sync_timeline_complete_point_locked(device, state, point);
              }
              return VK_SUCCESS;
          }'''

          idx = 0
          while True:
              idx = content.find(start_marker, idx)
              if idx == -1: break
              
              open_paren = content.find('(', idx)
              if open_paren == -1: idx += 1; continue
              
              balance = 0
              close_paren = -1
              for i in range(open_paren, len(content)):
                  if content[i] == '(': balance += 1
                  elif content[i] == ')': 
                      balance -= 1
                      if balance == 0: close_paren = i; break
              
              if close_paren == -1: idx += 1; continue
                  
              after_args = content[close_paren+1:]
              if after_args.lstrip().startswith('{'):
                  body_start = close_paren + 1 + after_args.find('{')
                  balance = 0
                  body_end = -1
                  for i in range(body_start, len(content)):
                      if content[i] == '{': balance += 1
                      elif content[i] == '}':
                          balance -= 1
                          if balance == 0: body_end = i + 1; break
                  
                  if body_end != -1:
                      content = content[:idx] + new_code + content[body_end:]
                      with open(path, 'w') as f: f.write(content)
                      print("Successfully patched vk_sync_timeline.c"); sys.exit(0)
              idx += 1
          print("Failed to find function definition"); sys.exit(1)
          EOF
          python3 vk_sync_fix.py

          # 5. A7xx Stability Fixes
          sed -i '/a7xx_gen1 = GPUProps(/,/)/ s/cs_lock_unlock_quirk = True,/cs_lock_unlock_quirk = True,\n        has_early_preamble = False,\n        has_scalar_predicates = False,/' src/freedreno/common/freedreno_devices.py
          sed -i '/a7xx_gen2 = GPUProps(/,/)/ s/has_image_processing = True,/has_image_processing = True,\n        has_early_preamble = False,\n        has_scalar_predicates = False,/' src/freedreno/common/freedreno_devices.py
          sed -i '/a7xx_gen3 = GPUProps(/,/)/ s/has_image_processing = True,/has_image_processing = True,\n        has_early_preamble = False,\n        has_scalar_predicates = False,/' src/freedreno/common/freedreno_devices.py

          # 6. Patch 01 & 02 logic
          # Remove FLUSHALL from case 8 if present
          sed -i '/case 8:/,/tu_device_entrypoints_a8xx/ { /TU_DEBUG_FLUSHALL/d }' src/freedreno/vulkan/tu_device.cc

          # Add UBWC version 5/6 support for newer Qualcomm kernels
          sed -i '/case KGSL_UBWC_4_0:/a \   case 5:\n   case 6:' src/freedreno/vulkan/tu_knl_kgsl.cc

          # Fix gralloc UBWC detection - replace legacy gmsm check with direct UBWC flag read
          cat <<'GRALLOC_EOF' > gralloc_fix.py
          import re
          path = 'src/util/u_gralloc/u_gralloc_fallback.c'
          with open(path, 'r') as f:
              content = f.read()

          # Pattern to find the old gmsm-based UBWC check block
          old_pattern = r'#ifdef HAS_FREEDRENO\s+uint32_t gmsm = .*?if \(hnd->handle->numInts >= 2 && hnd->handle->data\[hnd->handle->numFds\] == gmsm\) \{[^}]+\}'

          new_code = '''#ifdef HAS_FREEDRENO
             /* This UBWC flag was introduced in a5xx. Newer Qualcomm gralloc
              * implementations (A8XX / Snapdragon 8 Elite) no longer use the legacy
              * 'gmsm' magic header, so always read the UBWC flag directly.
              */
             if (hnd->handle->numInts >= 2) {
                bool ubwc = hnd->handle->data[hnd->handle->numFds + 1] & 0x08000000;
                out->modifier = ubwc ? DRM_FORMAT_MOD_QCOM_COMPRESSED : DRM_FORMAT_MOD_LINEAR;
             }'''

          content = re.sub(old_pattern, new_code, content, flags=re.DOTALL)

          with open(path, 'w') as f:
              f.write(content)
          print("Gralloc UBWC fix applied")
          GRALLOC_EOF
          python3 gralloc_fix.py

          # Add ICD exports for emulator compatibility
          echo -e "vk_icdGetInstanceProcAddr\nvk_icdGetPhysicalDeviceProcAddr\nvk_icdNegotiateLoaderICDInterfaceVersion" >> src/vulkan/vulkan-icd-android-symbols.txt

          # 7. Fix sync.h symlink
          cd include/android_stub/sync && rm -f sync.h && cp ../android/sync.h sync.h

      - name: Apply Variant Specific Patches
        run: |
          cd mesa
          if [ "${{ matrix.variant }}" = "A8XX" ]; then
            # A8XX Gen1 devices (A810, A825, A829, A830) use IMR (Immediate Mode Rendering)
            # instead of TBR (Tile Based Rendering). GMEM doesn't work on these chips.
            # Gen2 devices (A840, X2-85) use TBR and work fine with GMEM.
            # Detection: Gen2 chip_ids have 0xffff prefix, Gen1 don't.

            # Add sysmem forcing for A8XX Gen1 devices in tu_device.cc
            cat <<'A8XX_SYSMEM_EOF' > a8xx_sysmem_fix.py
          import re
          path = 'src/freedreno/vulkan/tu_device.cc'
          with open(path, 'r') as f:
              content = f.read()

          # Find case 8: and add Gen1/Gen2 detection before the dispatch table setup
          old_pattern = r'(case 8:\s*\n)(\s*)(vk_device_dispatch_table_from_entrypoints\(\s*&dispatch_table, &tu_device_entrypoints_a8xx)'

          new_code = r'''\1\2/* A8XX Gen1 devices (A830/FD830, A810, A825, A829) need sysmem rendering
      * forced because they use IMR (Immediate Mode Rendering) instead of
      * traditional TBR (Tile Based Rendering). GMEM doesn't work properly.
      * A840 and X2-85 (Gen2) work fine with GMEM.
      *
      * Gen1 chip_ids: 0x4405xxxx (A830), 0x4401xxxx (A810), 0x4403xxxx (A825/A829)
      * Gen2 chip_ids: 0xffff4405xxxx (A840), 0xffff4407xxxx (X2-85)
      */
      {
         uint64_t chip = physical_device->dev_id.chip_id;
         bool is_gen2 = (chip >> 32) == 0xffff;
         if (!is_gen2) {
            tu_env.debug |= TU_DEBUG_SYSMEM;
         }
      }
      \3'''

          content = re.sub(old_pattern, new_code, content)

          with open(path, 'w') as f:
              f.write(content)
          print("A8XX Gen1 sysmem fix applied")
          A8XX_SYSMEM_EOF
            python3 a8xx_sysmem_fix.py

            # Fix fd6_gmem_cache.h for A8XX compatibility
            sed -i 's/if (info->chip >= 8)/if (info->chip >= 8 \&\& info->num_slices > 1)/' src/freedreno/common/fd6_gmem_cache.h
            sed -i '/if (info->chip >= 8 \&\& info->num_slices > 1)/!b;n;c\   {}' src/freedreno/common/fd6_gmem_cache.h

            # Patch a8xx_base in freedreno_devices.py
            cat <<'EOF' > variant_patch.py
          import re
          path = 'src/freedreno/common/freedreno_devices.py'
          with open(path, 'r') as f:
              content = f.read()

          # Pattern to find a8xx_base block
          pattern = r'(a8xx_base = GPUProps\()(.*?)(\n    \))'

          def replacement(match):
              header = match.group(1)
              body = match.group(2)
              footer = match.group(3)

              # Remove existing keys to avoid duplication
              body = re.sub(r'\s*has_fs_tex_prefetch\s*=\s*(?:True|False),', '', body)
              body = re.sub(r'\s*has_salu_int_narrowing_quirk\s*=\s*(?:True|False),', '', body)

              # Append new keys
              new_props = "\n        has_fs_tex_prefetch = True,\n        has_salu_int_narrowing_quirk = False,"

              return header + body + new_props + footer

          content = re.sub(pattern, replacement, content, flags=re.DOTALL)

          with open(path, 'w') as f:
              f.write(content)
          print("A8XX base properties patched")
          EOF
            python3 variant_patch.py

          elif [ "${{ matrix.variant }}" = "A840P" ]; then
            sed -i 's/if (cmd_buffer->state.rp.drawcall_count > 5)/if (cmd_buffer->state.rp.drawcall_count > 10)/' src/freedreno/vulkan/tu_autotune.cc
            sed -i 's/gmem_bandwidth = (gmem_bandwidth \* 11 + total_draw_call_bandwidth) \/ 10;/gmem_bandwidth = (gmem_bandwidth \* 10 + total_draw_call_bandwidth) \/ 10;/' src/freedreno/vulkan/tu_autotune.cc
          fi

      - name: Build Mesa
        run: |
          cd mesa
          # Note: LTO is prohibited in Mesa 26.1.0+ so we don't use -Db_lto=true
          meson setup build-android-aarch64 \
            -Dplatforms=android \
            -Dplatform-sdk-version=35 \
            -Dandroid-stub=true \
            -Dandroid-libbacktrace=disabled \
            -Degl=disabled \
            -Dgallium-drivers= \
            -Dvulkan-drivers=freedreno \
            -Dfreedreno-kmds=kgsl \
            -Dbuildtype=release \
            -Dstrip=true \
            -Dvulkan-beta=true \
            --cross-file=android-aarch64
          ninja -C build-android-aarch64 src/freedreno/vulkan/libvulkan_freedreno.so

      - name: Generate Upstream Changelog
        run: |
          cd mesa
          echo "===============================================================================" > ../CHANGELOG_UPSTREAM_24H.txt
          echo "  MESA UPSTREAM COMMITS (LAST 24 HOURS)" >> ../CHANGELOG_UPSTREAM_24H.txt
          echo "  BASE COMMIT: ${{ env.MESA_COMMIT }}" >> ../CHANGELOG_UPSTREAM_24H.txt
          echo "===============================================================================" >> ../CHANGELOG_UPSTREAM_24H.txt
          git log --since="24 hours ago" --format="* %h - %s" >> ../CHANGELOG_UPSTREAM_24H.txt

      - name: Package Driver
        run: |
          SO=mesa/build-android-aarch64/src/freedreno/vulkan/libvulkan_freedreno.so
          $ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip $SO
          patchelf --set-soname libvulkan_freedreno.so $SO
          patchelf --remove-rpath $SO
          mkdir package
          cp $SO package/
          cp CHANGELOG_UPSTREAM_24H.txt package/
          cat <<EOF > package/meta.json
          {
            "schemaVersion": 1,
            "name": "Turnip MTR Nightly ${{ matrix.variant }}",
            "description": "Mesa 26.1.0 Devel Nightly ${{ matrix.variant }}",
            "author": "MaxsTechReview",
            "packageVersion": "13",
            "vendor": "mesa",
            "driverVersion": "Mesa 26.1.0 Devel Nightly",
            "minApi": 29,
            "libraryName": "libvulkan_freedreno.so"
          }
          EOF
          # Filename now includes commit hash (e.g., Turnip_MTR_Nightly_a1b2c3d_A8XX.zip)
          cd package && zip -j ../Turnip_MTR_Nightly_${{ env.MESA_COMMIT }}_${{ matrix.variant }}.zip meta.json libvulkan_freedreno.so

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Turnip_MTR_Nightly_${{ env.MESA_COMMIT }}_${{ matrix.variant }}
          path: |
            Turnip_MTR_Nightly_${{ env.MESA_COMMIT }}_${{ matrix.variant }}.zip
            CHANGELOG_UPSTREAM_24H.txt
            
